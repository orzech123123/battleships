@using Battleships.Factories
@using Battleships.Models

@inject ShipFactory ShipFactory;
@inject IJSRuntime JsRuntime

<div @onclick="RestartGameAsync">Battleships (click to restart)</div>

<BoardComponent @ref="_playerBoardComponent" />
<BoardComponent @ref="_enemyBoardComponent" />

@code
{
    private BoardComponent _enemyBoardComponent;
    private BoardComponent _playerBoardComponent;

    private readonly IList<Ship> _enemyShips = new List<Ship>();
    private readonly IList<Ship> _playerShips = new List<Ship>();

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            InitializeGame();

            _enemyBoardComponent.AddOnClickListener(ProcessOnEnemyBoardClickAsync);
        }
    }

    private void InitializeGame()
    {
        _playerBoardComponent.Board.Clear();
        _enemyBoardComponent.Board.Clear();

        RandomizeShips(_playerShips, _playerBoardComponent.Board);
        RandomizeShips(_enemyShips, _enemyBoardComponent.Board);

        SetCellStatesOnPlayersBoard();
    }

    private void SetCellStatesOnPlayersBoard()
    {
        foreach (var playerShip in _playerShips)
        {
            foreach (var playerShipSegment in playerShip.Segments)
            {
                _playerBoardComponent.Board.SetCellState(playerShipSegment.X, playerShipSegment.Y, CellState.Ship);
            }
        }
    }

    private void RandomizeShips(ICollection<Ship> ships, Board board)
    {
        ships.Clear();

        var battleship = ShipFactory.CreateRandomShip(5, ships, board.Cols, board.Rows);
        ships.Add(battleship);
        var destroyer1 = ShipFactory.CreateRandomShip(4, ships, board.Cols, board.Rows);
        ships.Add(destroyer1);
        var destroyer2 = ShipFactory.CreateRandomShip(4, ships, board.Cols, board.Rows);
        ships.Add(destroyer2);
    }

    private async Task ProcessOnEnemyBoardClickAsync(int col, int row)
    {
        await ProcessTurn(col, row, _enemyBoardComponent, _enemyShips, "You won! Congratulations!");
    }

    private async Task ProcessTurn(
        int col,
        int row,
        BoardComponent oponentBoardComponent,
        ICollection<Ship> oponentShips,
        string gameOverMessage)
    {
        if (!ValidateCell(col, row, oponentBoardComponent)) return;

        HitOrMishitShip(col, row, oponentBoardComponent, oponentShips);

        SetShipsSunkStates(oponentBoardComponent, oponentShips);

        await CheckIfGameIsOver(oponentShips, gameOverMessage);

        await oponentBoardComponent.RedrawAsync();
    }

    private static bool ValidateCell(int col, int row, BoardComponent oponentBoardComponent)
    {
        var cellState = oponentBoardComponent.Board.GetCellState(col, row);

        //rules (now only one):
        return cellState == CellState.Empty;
    }

    private async Task CheckIfGameIsOver(ICollection<Ship> oponentShips, string gameOverMessage)
    {
        if (oponentShips.All(ship => ship.IsDestroyed))
        {
            await JsRuntime.InvokeAsync<string>("alert", gameOverMessage);
            await RestartGameAsync();
        }
    }

    private static void SetShipsSunkStates(BoardComponent oponentBoardComponent, ICollection<Ship> oponentShips)
    {
        foreach (var oponentShip in oponentShips)
        {
            if (oponentShip.IsDestroyed)
            {
                foreach (var segment in oponentShip.Segments)
                {
                    oponentBoardComponent.Board.SetCellState(segment.X, segment.Y, CellState.Sunk);
                }
            }
        }
    }

    private static void HitOrMishitShip(int col, int row, BoardComponent oponentBoardComponent, ICollection<Ship> oponentShips)
    {
        var hitShip = oponentShips.SingleOrDefault(ship => ship.Collides(col, row));
        if (hitShip != null)
        {
            hitShip.DamageSegment(col, row);
            oponentBoardComponent.Board.SetCellState(col, row, CellState.Hit);
        }
        else
        {
            oponentBoardComponent.Board.SetCellState(col, row, CellState.Mishit);
        }
    }

    private async Task RestartGameAsync()
    {
        InitializeGame();

        await _playerBoardComponent.RedrawAsync();
        await _enemyBoardComponent.RedrawAsync();
    }
}
